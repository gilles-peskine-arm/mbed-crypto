/* BEGIN_HEADER */
#include "../library/psa_its_file.h"

/* Internal definitions of the implementation, copied for the sake of
 * some of the tests and of the cleanup code. */
#define PSA_ITS_STORAGE_PREFIX ""
#define PSA_ITS_STORAGE_FILENAME_PATTERN "%08lx.psa_its"
#define PSA_ITS_STORAGE_FILENAME_LENGTH         \
    ( sizeof( PSA_ITS_STORAGE_PREFIX ) + 16 )
#define PSA_ITS_STORAGE_TEMP PSA_ITS_STORAGE_PREFIX "tempfile.psa_its"

static void psa_its_fill_filename( uint32_t uid, char *filename )
{
    snprintf( filename, PSA_ITS_STORAGE_FILENAME_LENGTH,
              "%s" PSA_ITS_STORAGE_FILENAME_PATTERN,
              PSA_ITS_STORAGE_PREFIX, (unsigned long) uid );
}

#define MAX( m, n ) ( ( m ) > ( n ) ? ( m ) : ( n ) )

#define ITS_ASSERT( expr )                      \
    TEST_ASSERT( ( expr ) == PSA_ITS_SUCCESS )

/* Maximum uid used by the test, recorded so that cleanup() can delete
 * all files. 0xffffffff is excluded. */
static uint32_t uid_max = 0;

static void cleanup( void )
{
    char filename[PSA_ITS_STORAGE_FILENAME_LENGTH];
    uint32_t uid;
    for( uid = 0; uid < uid_max; uid++ )
    {
        psa_its_fill_filename( uid, filename );
        remove( filename );
    }
    psa_its_fill_filename( 0xffffffff, filename );
    remove( filename );
    remove( PSA_ITS_STORAGE_TEMP );
    uid_max = 0;
}

static psa_its_status_t psa_its_set_wrap( uint32_t uid,
                                          uint32_t data_length,
                                          const void *p_data,
                                          psa_its_create_flags_t create_flags )
{
    if( uid_max != 0xffffffff && uid_max < uid )
        uid_max = uid;
    return psa_its_set( uid, data_length, p_data, create_flags );
}

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PSA_ITS_FILE_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void set_get_remove( int uid_arg, int flags_arg, data_t *data )
{
    uint32_t uid = uid_arg;
    uint32_t flags = flags_arg;
    struct psa_its_info_t info;
    unsigned char *buffer = NULL;

    ASSERT_ALLOC( buffer, data->len );

    ITS_ASSERT( psa_its_set_wrap( uid, data->len, data->x, flags ) );

    ITS_ASSERT( psa_its_get_info( uid, &info ) );
    TEST_ASSERT( info.size == data->len );
    TEST_ASSERT( info.flags == flags );
    ITS_ASSERT( psa_its_get( uid, 0, data->len, buffer ) );
    ASSERT_COMPARE( data->x, data->len, buffer, data->len );

    ITS_ASSERT( psa_its_remove( uid ) );

exit:
    mbedtls_free( buffer );
    cleanup( );
}
/* END_CASE */

/* BEGIN_CASE */
void set_overwrite( int uid_arg,
                    int flags1_arg, data_t *data1,
                    int flags2_arg, data_t *data2 )
{
    uint32_t uid = uid_arg;
    uint32_t flags1 = flags1_arg;
    uint32_t flags2 = flags2_arg;
    struct psa_its_info_t info;
    unsigned char *buffer = NULL;

    ASSERT_ALLOC( buffer, MAX( data1->len, data2->len ) );

    ITS_ASSERT( psa_its_set_wrap( uid, data1->len, data1->x, flags1 ) );
    ITS_ASSERT( psa_its_get_info( uid, &info ) );
    TEST_ASSERT( info.size == data1->len );
    TEST_ASSERT( info.flags == flags1 );
    ITS_ASSERT( psa_its_get( uid, 0, data1->len, buffer ) );
    ASSERT_COMPARE( data1->x, data1->len, buffer, data1->len );

    ITS_ASSERT( psa_its_set_wrap( uid, data2->len, data2->x, flags2 ) );
    ITS_ASSERT( psa_its_get_info( uid, &info ) );
    TEST_ASSERT( info.size == data2->len );
    TEST_ASSERT( info.flags == flags2 );
    ITS_ASSERT( psa_its_get( uid, 0, data2->len, buffer ) );
    ASSERT_COMPARE( data2->x, data2->len, buffer, data2->len );

    ITS_ASSERT( psa_its_remove( uid ) );

exit:
    mbedtls_free( buffer );
    cleanup( );
}
/* END_CASE */

/* BEGIN_CASE */
void set_multiple( int first_id, int count )
{
    uint32_t uid0 = first_id;
    uint32_t uid;
    char stored[40];
    char retrieved[40];

    memset( stored, '.', sizeof( stored ) );
    for( uid = uid0; uid < uid0 + count; uid++ )
    {
        mbedtls_snprintf( stored, sizeof( stored ),
                          "Content of file 0x%08lx", (unsigned long) uid );
        ITS_ASSERT( psa_its_set_wrap( uid, sizeof( stored ), stored, 0 ) );
    }

    for( uid = uid0; uid < uid0 + count; uid++ )
    {
        mbedtls_snprintf( stored, sizeof( stored ),
                          "Content of file 0x%08lx", (unsigned long) uid );
        ITS_ASSERT( psa_its_get( uid, 0, sizeof( stored ), retrieved ) );
        ASSERT_COMPARE( retrieved, sizeof( stored ),
                        stored, sizeof( stored ) );
        ITS_ASSERT( psa_its_remove( uid ) );
        TEST_ASSERT( psa_its_get( uid, 0, 0, NULL ) ==
                     PSA_ITS_ERROR_KEY_NOT_FOUND );
    }

exit:
    cleanup( );
}
/* END_CASE */

/* BEGIN_CASE */
void nonexistent( int uid_arg, int create_and_remove )
{
    uint32_t uid = uid_arg;
    struct psa_its_info_t info;

    if( create_and_remove )
    {
        ITS_ASSERT( psa_its_set_wrap( uid, 0, NULL, 0 ) );
        ITS_ASSERT( psa_its_remove( uid ) );
    }

    TEST_ASSERT( psa_its_remove( uid ) == PSA_ITS_ERROR_KEY_NOT_FOUND );
    TEST_ASSERT( psa_its_get_info( uid, &info ) ==
                 PSA_ITS_ERROR_KEY_NOT_FOUND );
    TEST_ASSERT( psa_its_get( uid, 0, 0, NULL ) ==
                 PSA_ITS_ERROR_KEY_NOT_FOUND );

exit:
    cleanup( );
}
/* END_CASE */

/* BEGIN_CASE */
void get_at( int uid_arg, data_t *data,
             int offset, int length_arg,
             int expected_status )
{
    uint32_t uid = uid_arg;
    unsigned char *buffer = NULL;
    psa_its_status_t ist;
    size_t length = length_arg >= 0 ? length_arg : 0;
    unsigned char *trailer;
    size_t i;

    ASSERT_ALLOC( buffer, length + 16 );
    trailer = buffer + length;
    memset( trailer, '-', 16 );

    ITS_ASSERT( psa_its_set_wrap( uid, data->len, data->x, 0 ) );

    ist = psa_its_get( uid, offset, length_arg, buffer );
    TEST_ASSERT( ist == (psa_its_status_t) expected_status );
    if( ist == PSA_ITS_SUCCESS )
        ASSERT_COMPARE( data->x + offset, length,
                        buffer, length );
    for( i = 0; i < 16; i++ )
        TEST_ASSERT( trailer[i] == '-' );
    ITS_ASSERT( psa_its_remove( uid ) );

exit:
    mbedtls_free( buffer );
    cleanup( );
}
/* END_CASE */
